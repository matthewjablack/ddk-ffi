namespace ddk_ffi {
    string version();
    [Throws=DLCError]
    sequence<u8> convert_mnemonic_to_seed(string mnemonic, string? passphrase);
    [Throws=DLCError]
    sequence<u8> create_xpriv_from_parent_path(
        sequence<u8> xpriv,
        string base_derivation_path,
        string network,
        string path
    );
    [Throws=DLCError]
    sequence<u8> get_xpub_from_xpriv(sequence<u8> xpriv, string network);


    // DLC Transaction Creation Functions
    [Throws=DLCError]
    sequence<u8> create_fund_tx_locking_script(
        sequence<u8> local_fund_pubkey,
        sequence<u8> remote_fund_pubkey
    );
    
    [Throws=DLCError]
    DlcTransactions create_dlc_transactions(
        sequence<Payout> outcomes,
        PartyParams local_params,
        PartyParams remote_params,
        u32 refund_locktime,
        u64 fee_rate,
        u32 fund_lock_time,
        u32 cet_lock_time,
        u64 fund_output_serial_id
    );
    
    [Throws=DLCError]
    DlcTransactions create_spliced_dlc_transactions(
        sequence<Payout> outcomes,
        PartyParams local_params,
        PartyParams remote_params,
        u32 refund_locktime,
        u64 fee_rate,
        u32 fund_lock_time,
        u32 cet_lock_time,
        u64 fund_output_serial_id
    );
    
    [Throws=DLCError]
    Transaction create_cet(
        TxOutput local_output,
        u64 local_payout_serial_id,
        TxOutput remote_output,
        u64 remote_payout_serial_id,
        string fund_tx_id,
        u32 fund_vout,
        u32 lock_time
    );
    
    [Throws=DLCError]
    sequence<Transaction> create_cets(
        string fund_tx_id,
        u32 fund_vout,
        sequence<u8> local_final_script_pubkey,
        sequence<u8> remote_final_script_pubkey,
        sequence<Payout> outcomes,
        u32 lock_time,
        u64 local_serial_id,
        u64 remote_serial_id
    );
    
    [Throws=DLCError]
    Transaction create_refund_transaction(
        sequence<u8> local_final_script_pubkey,
        sequence<u8> remote_final_script_pubkey,
        u64 local_amount,
        u64 remote_amount,
        u32 lock_time,
        string fund_tx_id,
        u32 fund_vout
    );
    
    // Utility Functions
    boolean is_dust_output(TxOutput output);
    
    [Throws=DLCError]
    ChangeOutputAndFees get_change_output_and_fees(
        PartyParams params,
        u64 fee_rate
    );
    
    u32 get_total_input_vsize(sequence<TxInputInfo> inputs);
    
    [Throws=DLCError]
    boolean verify_fund_tx_signature(
        Transaction fund_tx,
        sequence<u8> signature,
        sequence<u8> pubkey,
        string txid,
        u32 vout,
        u64 input_amount
    );

    [Throws=DLCError]
    Transaction add_signature_to_transaction(
        Transaction tx,
        sequence<u8> signature,
        sequence<u8> pubkey,
        u32 input_index
    );

    [Throws=DLCError]
    Transaction sign_multi_sig_input(
        Transaction tx,
        DlcInputInfo dlc_input,
        sequence<u8> local_privkey,
        sequence<u8> remote_signature
    );

    [Throws=DLCError]
    Transaction sign_cet(
        Transaction cet,
        sequence<u8> adaptor_signature,
        sequence<sequence<u8>> oracle_signatures,
        sequence<u8> funding_secret_key,
        sequence<u8> other_pubkey,
        sequence<u8> funding_script_pubkey,
        u64 fund_output_value
    );

    [Throws=DLCError]
    sequence<AdaptorSignature> create_cet_adaptor_sigs_from_oracle_info(
        sequence<Transaction> cets,
        sequence<OracleInfo> oracle_info,
        sequence<u8> funding_secret_key,
        sequence<u8> funding_script_pubkey,
        u64 fund_output_value,
        sequence<sequence<sequence<sequence<u8>>>> msgs
    );

    [Throws=DLCError]
    sequence<sequence<u8>> create_cet_adaptor_points_from_oracle_info(
        sequence<OracleInfo> oracle_info,
        sequence<sequence<sequence<sequence<u8>>>> msgs
    );

    boolean verify_cet_adaptor_sigs_from_oracle_info(
        sequence<AdaptorSignature> adaptor_sigs,
        sequence<Transaction> cets,
        sequence<OracleInfo> oracle_info,
        sequence<u8> pubkey,
        sequence<u8> funding_script_pubkey,
        u64 total_collateral,
        sequence<sequence<sequence<sequence<u8>>>> msgs
    );

    boolean verify_cet_adaptor_sig_from_oracle_info(
        AdaptorSignature adaptor_sig,
        Transaction cet,
        sequence<OracleInfo> oracle_info,
        sequence<u8> pubkey,
        sequence<u8> funding_script_pubkey,
        u64 total_collateral,
        sequence<sequence<sequence<u8>>> msgs
    );
    
    // Signing Functions
    [Throws=DLCError]
    sequence<u8> get_raw_funding_transaction_input_signature(
        Transaction funding_transaction,
        sequence<u8> privkey,
        string prev_tx_id,
        u32 prev_tx_vout,
        u64 value
    );
    
    [Throws=DLCError]
    Transaction sign_fund_transaction_input(
        Transaction fund_transaction,
        sequence<u8> privkey,
        string prev_tx_id,
        u32 prev_tx_vout,
        u64 value
    );
    
    // Adaptor Signature Functions
    [Throws=DLCError]
    AdaptorSignature create_cet_adaptor_signature_from_oracle_info(
        Transaction cet,
        OracleInfo oracle_info,
        sequence<u8> funding_sk,
        sequence<u8> funding_script_pubkey,
        u64 total_collateral,
        sequence<sequence<u8>> msgs
    );
};

// Transaction representation
dictionary Transaction {
    i32 version;
    u32 lock_time;
    sequence<TxInput> inputs;
    sequence<TxOutput> outputs;
    sequence<u8> raw_bytes;
};

// Transaction input
dictionary TxInput {
    string txid;
    u32 vout;
    sequence<u8> script_sig;
    u32 sequence;
    sequence<sequence<u8>> witness;
};

// Transaction output  
dictionary TxOutput {
    u64 value;
    sequence<u8> script_pubkey;
};

// Input information for funding
dictionary TxInputInfo {
    string txid;
    u32 vout;
    sequence<u8> script_sig;
    u32 max_witness_length;
    u64 serial_id;
};

// Payout for offer and accept parties
dictionary Payout {
    u64 offer;
    u64 accept;
};

// Parameters for a party in the DLC
dictionary PartyParams {
    sequence<u8> fund_pubkey;
    sequence<u8> change_script_pubkey;
    u64 change_serial_id;
    sequence<u8> payout_script_pubkey;
    u64 payout_serial_id;
    sequence<TxInputInfo> inputs;
    u64 input_amount;
    u64 collateral;
    sequence<DlcInputInfo> dlc_inputs;
};

dictionary DlcInputInfo {
    Transaction fund_tx;
    u32 fund_vout;
    sequence<u8> local_fund_pubkey;
    sequence<u8> remote_fund_pubkey;
    u64 fund_amount;
    u32 max_witness_len;
    u64 input_serial_id;
    sequence<u8> contract_id;
};

// Container for all DLC transactions
dictionary DlcTransactions {
    Transaction fund;
    sequence<Transaction> cets;
    Transaction refund;
    sequence<u8> funding_script_pubkey;
};

// Adaptor signature with proof
dictionary AdaptorSignature {
    sequence<u8> signature;
    sequence<u8> proof;
};

// Change output and fees result
dictionary ChangeOutputAndFees {
    TxOutput change_output;
    u64 fund_fee;
    u64 cet_fee;
};

// Oracle information
dictionary OracleInfo {
    sequence<u8> public_key;
    sequence<sequence<u8>> nonces;
};

// Error types for DLC operations
[Error]
enum DLCError {
    "InvalidSignature",
    "InvalidPublicKey",
    "InvalidTransaction",
    "InsufficientFunds",
    "InvalidArgument",
    "SerializationError",
    "Secp256k1Error",
    "MiniscriptError",
    "InvalidNetwork",
    "KeyError",
};

[Error]
enum ExtendedKey {
    "InvalidMnemonic",
    "InvalidXpriv",
    "InvalidXpub",
    "InvalidDerivationPath",
};